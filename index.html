<!--
TROUBLESHOOTING GUIDE:
======================
If you see "CSV is not found or CSV is empty" error:

1. CHECK CONSOLE (F12 > Console tab):
   - Look for error messages like "? No data records found in CSV"
   - Check for XLSX conversion errors

2. MOST COMMON ISSUE - ML SENTIMENT API DOWN:
   - If seeing long loading spinner, ML API might be down
   - QUICK FIX: Set USE_ML_SENTIMENT = false (around line 320)
   - To enable ML again: python ml_sentiment_api.py

3. VERIFY DATA FILES:
   - reviews.xlsx should be ~50-100MB
   - stores_master.xlsx should be ~5-10MB
   - Both files should be in same folder as this HTML

4. VERIFY FILES ARE LOADABLE:
   - Open browser console (F12)
   - Check network tab for 404 errors on fetch requests
   - Look for CORS issues (red errors)

5. CACHE ISSUE:
   - Hard refresh: Ctrl+Shift+R (Windows) or Cmd+Shift+R (Mac)
   - Clear browser cache if loading old version

6. FOR DEVELOPERS:
   - Check console logs - they show detailed loading progress
   - Look for: ? Loaded: filename | ? Could not load: filename
   - Check: 📋 First 300 chars of reviews, 📊 CSV sizes
-->

<!-- GitHub Configuration for CSV/XLSX Loading -->
<script type="text/javascript">
  const GITHUB_CONFIG = {
    username: 'Harishbose',
    repo: 'metro-voc-dashboard',
    branch: 'main'
  };
  
  // Make it globally available
  window.GITHUB_CONFIG = GITHUB_CONFIG;

  // Helper function to try loading from GitHub with multiple formats and name variations
  async function fetchFromGitHub(baseFileName, alternateFileName = null) {
    const fileNames = [baseFileName];
    if (alternateFileName) {
      fileNames.push(alternateFileName);
    }
    
    const formats = ['.csv', '.xlsx'];
    
    for (const fileName of fileNames) {
      for (const format of formats) {
        const fullFileName = fileName + format;
        const url = `https://raw.githubusercontent.com/${GITHUB_CONFIG.username}/${GITHUB_CONFIG.repo}/${GITHUB_CONFIG.branch}/${fullFileName}`;
        
        try {
          const response = await fetch(url);
          if (response.ok) {
            console.log(`? Loaded: ${fullFileName}`);
            if (format === '.csv') {
              return await response.text();
            } else if (format === '.xlsx') {
              const arrayBuffer = await response.arrayBuffer();
              return { arrayBuffer, isXlsx: true };
            }
          }
        } catch (error) {
          console.log(`Could not load ${fullFileName}, trying next...`);
        }
      }
    }
    
    throw new Error(`Could not load ${baseFileName} in any supported format (CSV or XLSX)`);
  }

  // Fix mojibake (corrupted emoji and text) - using safe unicode escapes
  function fixMojibake(text) {
    if (!text || typeof text !== 'string') return text;
    try {
      let fixed = text;
      
      // Map mojibake patterns to replacements using Unicode escapes to avoid syntax errors
      // Mojibake emoji patterns (UTF-8 bytes decoded as Latin-1)
      fixed = fixed.split('\u00f0\u009f\u0098\u0085').join('??'); // sweat smile
      fixed = fixed.split('\u00f0\u009f\u0098\u0092').join('??'); // unamused
      fixed = fixed.split('\u00f0\u009f\u0098\u0094').join('??'); // pensive
      fixed = fixed.split('\u00f0\u009f\u0098\u0095').join('??'); // confused
      fixed = fixed.split('\u00f0\u009f\u0098\u00af').join('??'); // hushed
      fixed = fixed.split('\u00f0\u009f\u0098\u00a2').join('??'); // crying
      fixed = fixed.split('\u00f0\u009f\u0098\u00ad').join('??'); // loudly crying
      fixed = fixed.split('\u00f0\u009f\u0091\u008c').join('??'); // OK hand
      
      // Text mojibake patterns
      fixed = fixed.split('\u00e2\u0080\u0099').join("'"); // apostrophe
      fixed = fixed.split('\u00e2\u0080\u009c').join('"'); // opening quote
      fixed = fixed.split('\u00e2\u0080\u009d').join('"'); // closing quote
      fixed = fixed.split('\u00c2\u00a0').join(' ');      // non-breaking space
      
      return fixed;
    } catch (e) {
      return text;
    }
  }

  // Convert XLSX to CSV text with better error handling
  function xlsxToCSV(arrayBuffer) {
    try {
      const workbook = XLSX.read(new Uint8Array(arrayBuffer), { type: 'array' });
      console.log('📊 XLSX Workbook loaded. Sheets:', workbook.SheetNames);
      
      const firstSheetName = workbook.SheetNames[0];
      console.log('📄 Using sheet:', firstSheetName);
      
      const worksheet = workbook.Sheets[firstSheetName];
      const csv = XLSX.utils.sheet_to_csv(worksheet);
      
      console.log('? XLSX converted to CSV. First 200 chars:', csv.substring(0, 200));
      return csv;
    } catch (error) {
      console.error('? Error converting XLSX to CSV:', error);
      throw new Error('Failed to convert XLSX file: ' + error.message);
    }
  }

  async function loadDataFromGitHub() {
    try {
      // Try to load local files first (for local/Render deployment)
      console.log('⚙️ Attempting to load local Excel files...');
      
      try {
        // Try XLSX files first
        const reviewsResponse = await fetch('./reviews.xlsx');
        const storesResponse = await fetch('./stores_master.xlsx');
        
        if (reviewsResponse.ok && storesResponse.ok) {
          const reviewsBuffer = await reviewsResponse.arrayBuffer();
          const storesBuffer = await storesResponse.arrayBuffer();
          
          // Check if buffers are not empty
          if (reviewsBuffer.byteLength === 0 || storesBuffer.byteLength === 0) {
            throw new Error('Downloaded files are empty');
          }
          
          const reviewsCSV = xlsxToCSV(reviewsBuffer);
          const storesCSV = xlsxToCSV(storesBuffer);
          
          // Validate CSV content
          if (!reviewsCSV || reviewsCSV.trim().length === 0 || !storesCSV || storesCSV.trim().length === 0) {
            console.warn('⚠️ XLSX conversion resulted in empty CSV');
            throw new Error('XLSX to CSV conversion failed - empty result');
          }
          
          console.log('? Local Excel files loaded (reviews.xlsx, stores_master.xlsx)');
          console.log('📊 Reviews CSV size:', reviewsCSV.length, 'bytes');
          console.log('📦 Stores CSV size:', storesCSV.length, 'bytes');
          return { 
            reviewsText: reviewsCSV, 
            storesText: storesCSV,
            source: 'Local (India Data - XLSX)'
          };
        }
      } catch (e) {
        console.log('❌ XLSX files error:', e.message);
      }
      
      try {
        // Fallback to CSV files (local)
        const reviewsResponse = await fetch('./reviews.csv');
        const storesResponse = await fetch('./stores_master.csv');
        
        if (reviewsResponse.ok && storesResponse.ok) {
          const reviewsText = await reviewsResponse.text();
          const storesText = await storesResponse.text();
          
          if (!reviewsText || reviewsText.trim().length === 0 || !storesText || storesText.trim().length === 0) {
            throw new Error('CSV files are empty');
          }
          
          console.log('? Local CSV files loaded (reviews.csv, stores_master.csv)');
          console.log('📊 Reviews CSV size:', reviewsText.length, 'bytes');
          console.log('📦 Stores CSV size:', storesText.length, 'bytes');
          return { 
            reviewsText, 
            storesText,
            source: 'Local (Data - CSV)'
          };
        }
      } catch (e) {
        console.log('❌ CSV files error:', e.message);
      }
      
      // Fallback to GitHub (if local files not found)
      console.log('🌐 Loading from GitHub (fallback)...');
      const reviewsData = await fetchFromGitHub('reviews');
      const reviewsText = reviewsData.isXlsx 
        ? xlsxToCSV(reviewsData.arrayBuffer)
        : reviewsData;
      
      if (!reviewsText || reviewsText.trim().length === 0) {
        throw new Error('Reviews data is empty after loading');
      }
      
      const storesData = await fetchFromGitHub('stores_master', 'store_master');
      const storesText = storesData.isXlsx 
        ? xlsxToCSV(storesData.arrayBuffer)
        : storesData;
      
      if (!storesText || storesText.trim().length === 0) {
        throw new Error('Stores data is empty after loading');
      }
      
      console.log('? GitHub files loaded');
      console.log('?? Reviews CSV size:', reviewsText.length, 'bytes');
      console.log('?? Stores CSV size:', storesText.length, 'bytes');
      return { 
        reviewsText, 
        storesText,
        source: 'GitHub'
      };
    } catch (error) {
      console.error('Data load error:', error);
      throw error;
    }
  }
</script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CX - Voice of Customer Dashboard</title>
  <!-- Including Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Including necessary JavaScript libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chrono-node/1.3.11/chrono.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.12.7/Recharts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: 'Roboto', sans-serif; background-color: #f3f4f6; }
    .kpi-card { transition: transform 0.2s; }
    .kpi-card:hover { transform: scale(1.05); }
    .filter-drawer { transition: width 0.3s; }
    .word-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 280px;
      overflow: hidden;
      padding: 10px;
      box-sizing: border-box;
    }
    .word-cloud span {
      padding: 5px 10px;
      border-radius: 12px;
      white-space: nowrap;
      line-height: 1.2;
    }
    .comment-card {
      background-color: #f9fafb;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .comment-header {
      color: #3b82f6;
    }
    .comment-details {
      font-size: 0.85rem;
      color: #6b7280;
    }
    .bar-label {
      fill: #000;
      font-size: 12px;
      font-weight: bold;
      text-anchor: middle;
      paint-order: stroke;
      stroke: #fff;
      stroke-width: 2px;
    }
    .heatmap-card {
      background-color: #ffffff;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .heatmap-cell {
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
      font-size: 0.9rem;
      min-width: 60px;
      cursor: pointer; /* Add cursor pointer for interactivity */
    }
    .chart-title {
      color: #000000;
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 16px;
    }
    .filter-search {
      width: 100%;
      padding: 8px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    .filter-options {
      max-height: 160px;
      overflow-y: auto;
      padding-right: 8px;
    }
    /* Custom style for X-axis labels */
    .custom-x-axis-label {
      font-size: 12px;
      fill: #333;
      text-anchor: middle;
      white-space: pre-wrap;
    }
    /* Insight card hover effect */
    .insight-card {
      transition: box-shadow 0.2s;
    }
    .insight-card:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Rendering the React application -->
  <script type="text/babel">
    // Defining the main React component
    const { useState, useEffect } = React;
    const {
      BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
      PieChart, Pie, Cell, LineChart, Line, LabelList
    } = Recharts;

    // Defining color palette
    const COLORS = {
      POSITIVE: '#10b981',
      NEGATIVE: '#ef4444',
      NEUTRAL: '#f59e0b',
      POSITIVE_LIGHT: '#2dd4bf',
      NEGATIVE_LIGHT: '#f87171',
      NEUTRAL_LIGHT: '#facc15',
      NONE: '#d1d5db'
    };

    // Defining emotion list
    const EMOTIONS = [
      { name: 'Satisfaction', color: '#10b981' },
      { name: 'Neutral', color: '#f59e0b' },
      { name: 'Appreciation', color: '#2dd4bf' },
      { name: 'Happy', color: '#34d399' },
      { name: 'Gratitude', color: '#6ee7b7' },
      { name: 'Frustration', color: '#ef4444' },
      { name: 'Disappointment', color: '#f87171' },
      { name: 'Anger', color: '#dc2626' },
      { name: 'Joy', color: '#22c55e' },
      { name: 'Trust', color: '#059669' },
      { name: 'Confusion', color: '#d97706' },
      { name: 'Sadness', color: '#b91c1c' }
    ];

    // Main Dashboard component
    function Dashboard() {
      const [data, setData] = useState([]);
      const [isLoading, setIsLoading] = useState(true);
      const [loadError, setLoadError] = useState(null);
      const [dataSource, setDataSource] = useState('');
      const storeMasterLookupRef = React.useRef({});  // STORE MASTER LOOKUP - GLOBAL ACCESS
      const [filters, setFilters] = useState({
        businessName: '', // Empty = show all brands
        zone: [],
        state: [],
        city: [],
        storeCode: [],
        mallHS: [],
        sentiment: [],
        financialYear: [],
        quarter: [],
        month: [],
        ImprovementCategory: []
      });
      const [showFilters, setShowFilters] = useState(true);
      const [filterSearch, setFilterSearch] = useState({});
      const [lowestZoneInsight, setLowestZoneInsight] = useState({
        zone: 'N/A',
        avgRating: 'N/A',
        reason: 'No data available'
      });
      const [showSubDrivers, setShowSubDrivers] = useState(false);
      const [selectedKeyDriver, setSelectedKeyDriver] = useState(null);
      const [keywordPopup, setKeywordPopup] = useState(null);
      const [mlSentimentStatus, setMlSentimentStatus] = useState('not-started'); // 'not-started', 'analyzing', 'completed', 'unavailable'

      // ML Sentiment Analysis Configuration
      const ML_SENTIMENT_API_URL = 'http://localhost:5000';
      // IMPORTANT: Set to false if ML API is not running - this will prevent the dashboard from hanging
      const USE_ML_SENTIMENT = false; // Set to false temporarily if ML API is down
      
      // Health check for ML API
      const checkMLAPIHealth = async () => {
        try {
          const response = await fetch(`${ML_SENTIMENT_API_URL}/health`, {
            method: 'GET',
            timeout: 5000
          });
          return response.ok;
        } catch (error) {
          console.warn('?? ML API health check failed:', error.message);
          return false;
        }
      };

      // Function to enrich data with ML sentiment
      const enrichWithMLSentiment = async (data) => {
        if (!USE_ML_SENTIMENT) {
          console.log('?? ML Sentiment disabled - using original sentiment');
          return data;
        }

        try {
          setMlSentimentStatus('analyzing');
          console.log('?? Starting ML sentiment analysis on', data.length, 'records...');
          
          // Check if ML API is available first
          const isAPIHealthy = await checkMLAPIHealth();
          if (!isAPIHealthy) {
            console.warn('?? ML API is not available, using original data');
            setMlSentimentStatus('unavailable');
            return data;
          }

          // Prepare comments for batch analysis
          const comments = data.map((row, idx) => ({
            id: idx,
            text: row['Customer Response'] || 'No comment'
          }));

          // Call ML API in batches (max 100 per request to avoid timeout)
          const batchSize = 100;
          const allResults = [];
          const timeoutMs = 30000; // 30 second timeout per batch

          for (let i = 0; i < comments.length; i += batchSize) {
            const batch = comments.slice(i, i + batchSize);
            console.log(`?? Analyzing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(comments.length / batchSize)}...`);

            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
              
              const response = await fetch(`${ML_SENTIMENT_API_URL}/batch-analyze`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ comments: batch }),
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
              
              if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
              }

              const result = await response.json();
              allResults.push(...result.results);
            } catch (err) {
              if (err.name === 'AbortError') {
                console.warn(`?? Batch ${Math.floor(i / batchSize) + 1} timed out after ${timeoutMs}ms`);
              } else {
                console.warn(`?? Batch ${Math.floor(i / batchSize) + 1} failed:`, err.message);
              }
              // On error, add dummy results to maintain index alignment
              batch.forEach(comment => {
                allResults.push({
                  id: comment.id,
                  sentiment: 'NEUTRAL',
                  pos_score: 0,
                  neu_score: 1,
                  neg_score: 0,
                  error: 'Analysis failed'
                });
              });
            }
          }

          // Merge ML sentiment into original data
          const enrichedData = data.map((row, idx) => {
            const mlResult = allResults.find(r => r.id === idx);
            if (mlResult && !mlResult.error) {
              return {
                ...row,
                'Sentiment': mlResult.sentiment,
                'ML_Sentiment': mlResult.sentiment,
                'ML_Pos_Score': mlResult.pos_score,
                'ML_Neu_Score': mlResult.neu_score,
                'ML_Neg_Score': mlResult.neg_score,
                'ML_Confidence': mlResult.confidence || 0
              };
            }
            return row;
          });

          // Calculate statistics
          const stats = {
            total: enrichedData.length,
            positive: enrichedData.filter(r => r.ML_Sentiment === 'POSITIVE').length,
            negative: enrichedData.filter(r => r.ML_Sentiment === 'NEGATIVE').length,
            neutral: enrichedData.filter(r => r.ML_Sentiment === 'NEUTRAL').length
          };

          console.log('? ML Sentiment analysis complete!');
          console.log('?? Distribution:', `Positive: ${stats.positive} (${(stats.positive/stats.total*100).toFixed(1)}%), Negative: ${stats.negative} (${(stats.negative/stats.total*100).toFixed(1)}%), Neutral: ${stats.neutral} (${(stats.neutral/stats.total*100).toFixed(1)}%)`);
          setMlSentimentStatus('completed');
          return enrichedData;
        } catch (error) {
          console.warn('?? ML Sentiment API unavailable:', error.message);
          console.log('?? Make sure to run: python ml_sentiment_api.py');
          console.log('?? API should be at:', ML_SENTIMENT_API_URL);
          setMlSentimentStatus('unavailable');
          return data; // Return original data without ML sentiment
        }
      };

      // Loading and processing data from GitHub
      useEffect(() => {
        const fetchData = async () => {
          setIsLoading(true);
          setLoadError(null);
          try {
            console.log('?? Starting data fetch...');
            const { reviewsText, storesText, source } = await loadDataFromGitHub();
            setDataSource(source);
            console.log('? Data fetched from:', source);
            console.log('?? First 300 chars of reviews:', reviewsText.substring(0, 300));
            
            // Parse reviews CSV WITHOUT transformHeader
            Papa.parse(reviewsText, {
              header: true,
              skipEmptyLines: true,
              dynamicTyping: false,
              complete: (results) => {
                console.log('? Reviews parsed. Records:', results.data.length);
                
                // Validate parsed data
                if (!results.data || results.data.length === 0) {
                  console.error('? No data records found in CSV');
                  setLoadError('CSV file is empty - no data records found');
                  setIsLoading(false);
                  return;
                }
                
                console.log('?? Review headers:', Object.keys(results.data[0] || {}));
                console.log('?? First review row:', results.data[0]);
                console.log('? Has Customer Response?', 'Customer Response' in (results.data[0] || {}));
                console.log('? Has Sentiment?', 'Sentiment' in (results.data[0] || {}));
                
                // Parse stores master for mapping
                Papa.parse(storesText, {
                  header: true,
                  skipEmptyLines: true,
                  dynamicTyping: false,
                  complete: (storesResults) => {
                    console.log('? Stores parsed. Records:', storesResults.data.length);
                    
                    // Validate stores data
                    if (!storesResults.data || storesResults.data.length === 0) {
                      console.warn('?? Stores data is empty, proceeding with reviews only');
                    }
                    
                    console.log('?? Store headers:', Object.keys(storesResults.data[0] || {}));
                    console.log('?? First store row:', storesResults.data[0]);
                    
                    const result = processAndCleanData(results.data, storesResults.data);
                    const cleanedData = result.data;
                    const storeMasterLookup = result.storeMasterLookup;
                    
                    // Store the lookup in the ref for global access
                    storeMasterLookupRef.current = storeMasterLookup;
                    
                    console.log('? Data cleaned. Final records:', cleanedData.length);
                    console.log('? Store Master Lookup available:', Object.keys(storeMasterLookup).length, 'stores');
                    
                    if (cleanedData.length === 0) {
                      console.error('? No records after cleaning!');
                      console.log('?? Debugging info:');
                      console.log('   - Total raw reviews:', results.data.length);
                      console.log('   - Total stores:', storesResults.data.length);
                      console.log('   - First 3 reviews:', results.data.slice(0, 3));
                    } else {
                      console.log('? SUCCESS: Dashboard ready with', cleanedData.length, 'records');
                      
                      // Enrich with ML sentiment
                      enrichWithMLSentiment(cleanedData).then(enrichedData => {
                        console.log('? ML enrichment completed, setting data:', enrichedData.length, 'records');
                        setData(enrichedData);
                      }).catch(err => {
                        console.warn('?? ML sentiment enrichment failed:', err.message);
                        console.log('Using original data without ML sentiment');
                        setData(cleanedData);
                      });
                    }
                    setIsLoading(false);
                  },
                  error: (err) => {
                    console.error('? Error parsing stores master:', err);
                    setLoadError('Failed to parse stores master file');
                    setIsLoading(false);
                  }
                });
              },
              error: (err) => {
                console.error('? Error parsing reviews:', err);
                setLoadError('Failed to parse reviews file');
                setIsLoading(false);
              }
            });
          } catch (error) {
            console.error('? Failed to fetch data from GitHub:', error);
            setLoadError(`Failed to load data from GitHub: ${error.message}`);
            setIsLoading(false);
          }
        };
        
        fetchData();
      }, []);

      // Processing and cleaning data with store master mapping
      const processAndCleanData = (rawData, storesMasterData = []) => {
        console.log('?? Processing reviews data. Raw records:', rawData.length);
        console.log('?? Store master records:', storesMasterData.length);
        
        if (!rawData || rawData.length === 0) {
          console.error('? No raw data to process!');
          return [];
        }
        
        // Log actual column names from reviews
        const firstRow = rawData[0];
        console.log('?? Review columns:', Object.keys(firstRow));
        
        // Build store master lookup by store name/code
        const storeMasterLookup = {};
        
        console.log('?? Building store lookup from', storesMasterData.length, 'stores...');
        
        // Create lookup map - Store Code from reviews matches Store Name in store master
        console.log('??? Building store master lookup from', storesMasterData.length, 'stores...');
        
        storesMasterData.forEach((store, idx) => {
          // Extract Store Name which acts as the key matching Store Code in reviews
          const storeName = String(store['Store Name'] || store['store_name'] || store['StoreName'] || store['Name'] || '').trim();
          
          if (storeName) {
            const nameKey = storeName.toUpperCase();
            // Build the lookup indexed by Store Name (which matches Store Code in reviews)
            storeMasterLookup[nameKey] = {
              storeCode: storeName,  // Store Code in reviews = Store Name in master
              storeName: storeName,
              city: store['City'] || store['city'] || 'N/A',
              state: store['State'] || store['state'] || 'N/A',
              tier: store['Tier'] || store['tier'] || 'N/A',
              zone: store['Zone'] || store['zone'] || 'N/A',
              mallHS: store['Mall/HS'] || store['mall/hs'] || store['MallHS'] || 'N/A'
            };
            
            if (idx === 0) {
              console.log('?? First store master record:');
              console.log('   Store Name (raw):', store['Store Name']);
              console.log('   Store Name (processed):', storeName);
              console.log('   Lookup key:', nameKey);
              console.log('   Stored in lookup as:', storeMasterLookup[nameKey]);
            }
          }
        });
        
        console.log('? Store lookup created:', Object.keys(storeMasterLookup).length, 'stores');
        console.log('?? Sample lookup keys:', Object.keys(storeMasterLookup).slice(0, 10));
        
        // Helper to detect improvement categories from comment text
        const detectCategory = (text) => {
          if (!text) return 'Other';
          const lower = text.toLowerCase();
          if (lower.includes('staff') || lower.includes('service') || lower.includes('behavior')) return 'Staff/Service';
          if (lower.includes('clean') || lower.includes('hygiene') || lower.includes('dirty')) return 'Cleanliness';
          if (lower.includes('product') || lower.includes('quality') || lower.includes('defect')) return 'Product Quality';
          if (lower.includes('price') || lower.includes('cost') || lower.includes('expensive')) return 'Pricing';
          if (lower.includes('parking') || lower.includes('location') || lower.includes('access')) return 'Location/Access';
          if (lower.includes('decor') || lower.includes('ambiance') || lower.includes('layout')) return 'Store Ambiance';
          return 'Other';
        };
        
        // Helper to detect emotion from comment
        const detectEmotion = (text) => {
          if (!text) return 'Neutral';
          const lower = text.toLowerCase();
          if (lower.includes('great') || lower.includes('excellent') || lower.includes('amazing') || lower.includes('love')) return 'Joy';
          if (lower.includes('hate') || lower.includes('terrible') || lower.includes('awful') || lower.includes('worst')) return 'Anger';
          if (lower.includes('sad') || lower.includes('disappointed') || lower.includes('dissatisfied')) return 'Sadness';
          if (lower.includes('confus') || lower.includes('unclear') || lower.includes('don\'t understand')) return 'Confusion';
          return 'Neutral';
        };
        
        // Process reviews - enrich with store master data and AI insights
        const processedData = [];
        let skippedCount = 0;
        let enrichedCount = 0;
        let notFoundCount = 0;
        
        rawData.forEach((row, idx) => {
          // Get values from review - WITH DEFAULTS
          // Extract Store Code with multiple column name variations
          const storeCode = String(row['Store Code'] || row['store_code'] || row['StoreCode'] || row['Code'] || '').trim();
          const rating = String(row['Customer Rating'] || '3').trim(); // Default to 3 if missing
          const sentiment = String(row['Sentiment'] || 'NEUTRAL').trim(); // Default to NEUTRAL
          const comment = String(row['Customer Response'] || 'No comment').trim(); // Default text
          const date = row['Comment Date_NEW'] || new Date().toISOString();
          const business = row['Business Name'] || 'Metro';
          
          // Validate rating - convert to number, use 3 as fallback
          let ratingNum = parseInt(rating);
          if (isNaN(ratingNum) || ratingNum < 1 || ratingNum > 5) {
            ratingNum = 3; // Default neutral rating
            skippedCount++;
          }
          
          // Normalize sentiment - allow any value, will be handled downstream
          const normalizedSentiment = ['POSITIVE', 'NEGATIVE', 'NEUTRAL'].includes(sentiment.toUpperCase()) 
            ? sentiment.toUpperCase() 
            : 'NEUTRAL';
          
          // Lookup store from store master using Store Code (which maps to Store Name in master)
          let storeDetails = null;
          const storeCodeKey = storeCode.trim().toUpperCase();
          
          // Lookup: Store Code from reviews matches Store Name in store master
          if (storeCodeKey) {
            storeDetails = storeMasterLookup[storeCodeKey];
          }
          
          if (idx === 0) {
            console.log(`?? Row 0 lookup:`);
            console.log(`   storeCode (input): "${storeCode}"`);
            console.log(`   storeCodeKey (lookup key): "${storeCodeKey}"`);
            console.log(`   Found in lookup: ${!!storeDetails}`);
            console.log(`   storeDetails:`, storeDetails);
            console.log(`   Lookup has ${Object.keys(storeMasterLookup).length} entries`);
          }
          
          if (!storeDetails) {
            notFoundCount++;
            if (notFoundCount <= 5) {
              console.log(`??Row ${idx}: Store Code "${storeCode}" not found in store master (using defaults)`);
            }
          }
          
          // CREATE ENRICHED ROW with Store Master as source of truth + AI Insights
          const processedRow = {
            // Keep all original review fields FIRST
            ...row,
            
            // Then OVERRIDE with enriched/corrected values
            // From Reviews (main data) - CORRECTED
            "Store Code": storeDetails?.storeCode || storeCode || 'UNKNOWN',
            "Business Name": business,
            "Customer Rating": ratingNum,
            "Sentiment": normalizedSentiment,
            "Customer Response": fixMojibake(comment), // Fix emoji encoding
            "Comment Date_NEW": date,
            
            // From Store Master (source of truth for location data)
            "City": storeDetails?.city || 'N/A',
            "State": storeDetails?.state || 'N/A',
            "Zone": storeDetails?.zone || 'N/A',
            "Tier": storeDetails?.tier || 'N/A',
            "Mall/HS": storeDetails?.mallHS || 'N/A',
            
            // AI Insights (generated from comment text)
            "ImprovementCategory": classifyMainCategory(comment),
            "SubDriver": classifyMainCategory(comment) === 'Store Experience' ? classifyStoreExpSubDriver(comment) : null,
            "Emotion": detectEmotion(comment),
            "Response_Type": row['Response_Type'] || 'Feedback'
          };
          
          if (idx === 0) {
            console.log(`?? Row ${idx} ENRICHED ROW:`);
            console.log(`   "Store Code" field: "${processedRow["Store Code"]}"`);
            console.log(`   "City" field: "${processedRow["City"]}"`);
            console.log(`   Full row keys:`, Object.keys(processedRow).slice(0, 15));
          }
          
          if (idx < 2) {
            console.log(`?? Row ${idx}: StoreCode="${storeCode}" ? "${processedRow["Store Code"]}", City="${processedRow["City"]}"`);
          }
          
          processedData.push(processedRow);
          if (storeDetails) enrichedCount++;
        });
        
        console.log('? Processing complete.');
        console.log(`   Valid records: ${processedData.length}`);
        console.log(`   Enriched with Store Master: ${enrichedCount}`);
        console.log(`   Store Code not found: ${notFoundCount}`);
        console.log(`   Skipped (missing data): ${skippedCount}`);
        
        if (processedData.length > 0) {
          console.log('? Sample enriched row:', processedData[0]);
          console.log('   City:', processedData[0].City);
          console.log('   State:', processedData[0].State);
          console.log('   ImprovementCategory:', processedData[0].ImprovementCategory);
          console.log('   Emotion:', processedData[0].Emotion);
        }
        
        // Return both processed data and store master lookup for filter access
        return {
          data: processedData,
          storeMasterLookup: storeMasterLookup
        };
      };

      // ========================================
      // VOC CLASSIFICATION TAXONOMY v2
      // 7 Main Categories + Store Experience Sub-Drivers
      // ========================================
      
      // Main Category Classification (LEVEL 1)
      const classifyMainCategory = (response) => {
        if (!response || response.trim() === '') return 'Other';
        
        const text = response.toLowerCase().trim();
        
        // 1. CUSTOMER SUPPORT
        const customerSupportKeywords = [
          'assistance', 'complaint', 'customer care', 'follow-up', 'help', 'helpline',
          'issue resolution', 'no help', 'query', 'quick response', 'resolution',
          'responsive', 'slow response', 'support', 'support team', 'unresponsive'
        ];
        const customerSupportPhrases = [
          'great support', 'helpful helpline', 'issue not resolved', 'no response',
          'poor support', 'quick resolution', 'unhelpful customer care'
        ];
        
        // 2. PRICING & DISCOUNTS
        const pricingKeywords = [
          'affordable', 'bargain', 'budget', 'cheap', 'cost', 'costly', 'deal', 'discount',
          'expensive', 'offer', 'overpriced', 'price', 'price tag', 'pricing', 'sale',
          'value', 'value for money'
        ];
        const pricingPhrases = [
          'affordable price', 'good value', 'great deal', 'no discount',
          'overpriced item', 'price was high', 'too expensive'
        ];
        
        // 3. PRODUCT ASSORTMENT
        const assortmentKeywords = [
          'assortment', 'availability', 'available', 'collection', 'inventory',
          'limited choice', 'not in stock', 'options', 'out of stock', 'range',
          'selection', 'shortage', 'size', 'stock', 'unavailable', 'variety'
        ];
        const assortmentPhrases = [
          'great selection', 'limited variety', 'more sizes needed', 'no stock',
          'not available', 'out of stock', 'poor selection'
        ];
        
        // 4. PRODUCT QUALITY
        const qualityKeywords = [
          'broken', 'damaged', 'defect', 'durability', 'faulty', 'goods', 'high quality',
          'item', 'low quality', 'material', 'merchandise', 'performance', 'premium',
          'product', 'quality', 'reliability', 'substandard'
        ];
        const qualityPhrases = [
          'bad material', 'defective product', 'good material', 'high quality',
          'item was damaged', 'poor quality', 'product broke'
        ];
        
        // 5. PROMOTIONS & OFFERS
        const promotionKeywords = [
          'benefits', 'coupon', 'deal', 'discount code', 'exclusive deal', 'loyalty',
          'membership', 'missed promotion', 'no offer', 'offer', 'promo', 'promotion',
          'reward', 'special offer', 'voucher'
        ];
        const promotionPhrases = [
          'great offer', 'loyalty reward', 'no discount applied', 'no promotion',
          'promo code issue', 'special deal', 'used coupon'
        ];
        
        // 6. RETURN & REFUND POLICIES
        const returnKeywords = [
          'exchange', 'exchange problem', 'hassle', 'non-returnable', 'policy',
          'refund', 'refund issue', 'replacement', 'return', 'return denied',
          'return process', 'returnable', 'warranty'
        ];
        const returnPhrases = [
          'difficult return', 'easy return', 'exchange not allowed',
          'hassle-free exchange', 'no refund', 'refund took long',
          'return was rejected'
        ];
        
        // 7. STORE EXPERIENCE (LEVEL 1 - all keywords/phrases)
        const storeExpKeywords = [
          'ambiance', 'arrogant', 'assistance', 'atmosphere', 'attitude', 'behavior',
          'behaviour', 'billing', 'billing error', 'busy', 'cashier mistake', 'charge',
          'charged extra', 'checkout time', 'cleanliness', 'courteous', 'courtesy',
          'crowd', 'customer service', 'delay', 'disrespectful', 'double charge',
          'efficient', 'experience', 'fast', 'friendly', 'helpful', 'hold time',
          'hospitality', 'impolite', 'in-store', 'inefficient', 'interaction',
          'invoice', 'kind', 'line', 'long wait', 'manner', 'organized', 'overcharge',
          'payment', 'payment declined', 'payment issue', 'polite', 'professionalism',
          'queue', 'quick', 'receipt', 'respectful', 'rude', 'salesman', 'salesperson',
          'service', 'slow', 'staff', 'staff attitude', 'store environment', 'tidy',
          'time-consuming', 'transaction', 'turnaround', 'unprofessional', 'wait',
          'waiting', 'welcoming', 'wrong amount'
        ];
        const storeExpPhrases = [
          'arrogant employee', 'bad attitude', 'bad experience', 'billing mistake',
          'double charged', 'excellent staff', 'fast processing', 'great service',
          'helpful team', 'incorrect invoice', 'long queue', 'long wait',
          'overcharged me', 'payment failed', 'payment not processed',
          'pleasant visit', 'polite staff', 'poor queue management', 'poor service',
          'quick checkout', 'respectful service', 'rude staff', 'slow service',
          'store was clean', 'too much waiting', 'unpleasant visit',
          'unprofessional behavior', 'very kind', 'wrong billing'
        ];
        
        // Matching logic: Phrases first (highest priority), then keywords
        const allCategories = [
          { name: 'Customer Support', keywords: customerSupportKeywords, phrases: customerSupportPhrases },
          { name: 'Pricing & Discounts', keywords: pricingKeywords, phrases: pricingPhrases },
          { name: 'Product Assortment', keywords: assortmentKeywords, phrases: assortmentPhrases },
          { name: 'Product Quality', keywords: qualityKeywords, phrases: qualityPhrases },
          { name: 'Promotions & Offers', keywords: promotionKeywords, phrases: promotionPhrases },
          { name: 'Return & Refund Policies', keywords: returnKeywords, phrases: returnPhrases },
          { name: 'Store Experience', keywords: storeExpKeywords, phrases: storeExpPhrases }
        ];
        
        // PHRASE MATCHING (Priority 1 - Highest)
        for (const cat of allCategories) {
          for (const phrase of cat.phrases) {
            if (text.includes(phrase)) {
              return cat.name;
            }
          }
        }
        
        // KEYWORD MATCHING (Priority 2)
        let bestMatch = null;
        let maxKeywordMatches = 0;
        
        for (const cat of allCategories) {
          const matches = cat.keywords.filter(kw => text.includes(kw)).length;
          if (matches > maxKeywordMatches) {
            maxKeywordMatches = matches;
            bestMatch = cat.name;
          }
        }
        
        return bestMatch || 'Store Experience';
      };
      
      // Store Experience Sub-Driver Classification (LEVEL 2)
      const classifyStoreExpSubDriver = (response) => {
        if (!response || response.trim() === '') return 'Staff Behaviour & Attitude';
        
        const text = response.toLowerCase().trim();
        
        // SUB-DRIVER 1: Staff Behaviour & Attitude
        const staffBehavKeys = [
          'arrogant', 'attitude', 'bad attitude', 'behavior', 'behaviour', 'courteous', 'courtesy',
          'excellent staff', 'friendly', 'kind', 'manner', 'polite', 'polite staff', 'professionalism',
          'respectful', 'rude', 'rude staff', 'salesman', 'salesperson', 'staff', 'unprofessional',
          'unprofessional behavior', 'very kind'
        ];
        
        // SUB-DRIVER 2: Service Speed & Wait Time
        const speedQueueKeys = [
          'busy', 'crowd', 'delay', 'fast', 'efficient', 'line', 'long wait', 'quick', 'slow',
          'slow service', 'wait'
        ];
        
        // SUB-DRIVER 3: Billing, Payment & Transaction Experience
        const billingKeys = [
          'billing', 'billing mistake', 'charge', 'invoice', 'payment', 'payment failed',
          'receipt', 'transaction', 'wrong billing'
        ];
        
        // SUB-DRIVER 4: In-Store Service & Interaction
        const serviceInterKeys = [
          'interaction', 'hospitality', 'service'
        ];
        
        // SUB-DRIVER 5: Store Ambience & Cleanliness
        const ambienceKeys = [
          'ambiance', 'atmosphere', 'cleanliness', 'in-store', 'organized', 'store environment',
          'store was clean', 'pleasant visit', 'welcoming'
        ];
        
        const subDrivers = [
          { name: 'Staff Behaviour & Attitude', keywords: staffBehavKeys },
          { name: 'Service Speed & Wait Time', keywords: speedQueueKeys },
          { name: 'Billing, Payment & Transaction Experience', keywords: billingKeys },
          { name: 'In-Store Service & Interaction', keywords: serviceInterKeys },
          { name: 'Store Ambience & Cleanliness', keywords: ambienceKeys }
        ];
        
        // EXACT PHRASE/KEYWORD MATCHING - Find best match
        let bestSubMatch = 'Staff Behaviour & Attitude'; // Default if no match
        let maxMatches = 0;
        
        for (const subdrv of subDrivers) {
          const matches = subdrv.keywords.filter(kw => text.includes(kw)).length;
          if (matches > maxMatches) {
            maxMatches = matches;
            bestSubMatch = subdrv.name;
          }
        }
        
        return bestSubMatch;
      };
      
      // Main category detection function (for backward compatibility)
      const classifyImprovementCategory = (response) => {
        const mainCat = classifyMainCategory(response);
        // Store sub-driver as additional field if it's Store Experience
        return mainCat;
      };

      // Detecting emotion - SENTENCE-BASED WITH PROPER NEGATION HANDLING
      const detectEmotion = (response) => {
        if (!response || response.trim() === '') return 'Unknown';
        
        const text = response.toLowerCase();
        
        // COMPREHENSIVE EMOTION KEYWORD LISTS
        const satisfactionKeywords = ['great', 'excellent', 'superb', 'outstanding', 'wonderful', 'fantastic', 'awesome', 'impressed', 'satisfied', 'pleased', 'brilliant', 'perfect', 'flawless', 'remarkable'];
        const happyKeywords = ['good', 'nice', 'pleasant', 'delighted', 'happy', 'glad', 'cheerful', 'enjoyable', 'satisfactory'];
        const gratitudeKeywords = ['thank', 'grateful', 'appreciate', 'appreciated', 'thanks', 'thankful', 'kudos', 'respect'];
        const joyKeywords = ['love', 'loved', 'adore', 'amazing', 'incredible', 'delightful', 'exceeded expectations', 'best experience', 'favorite'];
        const trustKeywords = ['trust', 'reliable', 'dependable', 'consistent', 'confidence', 'assured', 'professional', 'trustworthy'];
        
        const frustrationKeywords = ['rude', 'unprofessional', 'awful', 'disrespectful', 'impolite', 'unfriendly', 'arrogant', 'hostile', 'unpleasant', 'frustrating', 'frustrated', 'irritating', 'annoying', 'insulted', 'bad attitude', 'rude staff'];
        const disappointmentKeywords = ['disappointed', 'disappointing', 'poor', 'bad', 'terrible', 'worst', 'pathetic', 'horrible', 'disgusting', 'not satisfied', 'unsatisfactory', 'subpar', 'below expectations'];
        const angerKeywords = ['angry', 'anger', 'furious', 'rage', 'enraged', 'upset', 'mad', 'infuriated', 'disgusted', 'hate', 'hated', 'despise', 'unacceptable'];
        const confusionKeywords = ['confused', 'confusion', 'unclear', 'confusing', 'complicated', 'not clear', 'uncertain', 'puzzled', 'mixed up', 'lost', 'bewildered'];
        const sadnessKeywords = ['sad', 'sadness', 'unhappy', 'depressed', 'regret', 'regretted', 'sorry', 'ashamed', 'dismayed', 'disheartened'];
        
        // Split into sentences
        const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
        
        let emotionScores = {
          'Satisfaction': 0, 'Happy': 0, 'Gratitude': 0, 'Joy': 0, 'Trust': 0,
          'Frustration': 0, 'Disappointment': 0, 'Anger': 0, 'Confusion': 0, 'Sadness': 0
        };
        
        // Process each sentence
        sentences.forEach(sentence => {
          // Helper function to check if keyword is negated
          const isKeywordNegated = (sentence, keyword) => {
            const keywordIndex = sentence.indexOf(keyword);
            if (keywordIndex === -1) return false;
            
            // Get text before keyword (look back up to 10 words / 50 characters)
            const beforeKeyword = sentence.substring(Math.max(0, keywordIndex - 50), keywordIndex);
            const negationWords = ['not', 'no', "don't", "didn't", "isn't", "wasn't", "aren't", "weren't", "can't", "couldn't", "haven't", "hasn't", "won't", "wouldn't", 'never', 'neither', 'nobody', 'nothing'];
            
            // Check if any negation word appears before the keyword
            return negationWords.some(neg => beforeKeyword.includes(neg));
          };
          
          // Check positive emotions
          satisfactionKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Disappointment'] += 2;  // Negated positive ? mild disappointment
              } else {
                emotionScores['Satisfaction'] += 3;
              }
            }
          });
          happyKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Disappointment'] += 1;
              } else {
                emotionScores['Happy'] += 2;
              }
            }
          });
          gratitudeKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Disappointment'] += 2;
              } else {
                emotionScores['Gratitude'] += 3;
              }
            }
          });
          joyKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Sadness'] += 2;
              } else {
                emotionScores['Joy'] += 3;
              }
            }
          });
          trustKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Confusion'] += 1;
              } else {
                emotionScores['Trust'] += 2;
              }
            }
          });
          
          // Check negative emotions - NEGATION FLIPS THEM TO POSITIVE
          frustrationKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Happy'] += 2;  // Not rude = good attitude
              } else {
                emotionScores['Frustration'] += 3;
              }
            }
          });
          disappointmentKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Satisfaction'] += 2;  // Not disappointing = satisfactory
              } else {
                emotionScores['Disappointment'] += 3;
              }
            }
          });
          angerKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Happy'] += 2;  // Not angry = positive
              } else {
                emotionScores['Anger'] += 3;
              }
            }
          });
          confusionKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Trust'] += 1;  // Not confused = clear/understandable
              } else {
                emotionScores['Confusion'] += 2;
              }
            }
          });
          sadnessKeywords.forEach(kw => {
            if (sentence.includes(kw)) {
              if (isKeywordNegated(sentence, kw)) {
                emotionScores['Happy'] += 2;  // Not sad = happy
              } else {
                emotionScores['Sadness'] += 3;
              }
            }
          });
        });
        
        // Find highest scoring emotion
        let maxEmotion = 'Neutral';
        let maxScore = 0;
        
        Object.entries(emotionScores).forEach(([emotion, score]) => {
          if (score > maxScore) {
            maxScore = score;
            maxEmotion = emotion;
          }
        });
        
        return maxScore > 0 ? maxEmotion : 'Neutral';
      };

      // Applying filters - SIMPLIFIED for safety
      console.log('?? Starting filter logic. Data length:', data.length);
      
      const filteredData = data.length > 0 ? data.filter(row => {
        // Basic existence check
        if (!row) return false;
        
        // Business name filter - only if specified (case-insensitive)
        if (filters.businessName && filters.businessName !== '') {
          const rowBusiness = (row["Business Name"] || '').toLowerCase().trim();
          const filterBusiness = filters.businessName.toLowerCase().trim();
          if (rowBusiness !== filterBusiness) {
            return false;
          }
        }
        
        // Financial Year filter
        if (filters.financialYear && filters.financialYear.length > 0) {
          const rowFY = row.FY || row['FY'] || '';
          if (!filters.financialYear.includes(rowFY)) return false;
        }
        
        // Quarter filter
        if (filters.quarter && filters.quarter.length > 0) {
          const rowQuarter = row.Quarter || row['Quarter'] || row.Q || '';
          if (!filters.quarter.includes(rowQuarter)) return false;
        }
        
        // Zone filter
        if (filters.zone && filters.zone.length > 0) {
          const rowZone = row.Zone || row.zone || '';
          if (!filters.zone.includes(rowZone)) return false;
        }
        
        // State filter
        if (filters.state && filters.state.length > 0) {
          const rowState = row.State || row.state || '';
          if (!filters.state.includes(rowState)) return false;
        }
        
        // City filter
        if (filters.city && filters.city.length > 0) {
          const rowCity = row.City || row.city || '';
          if (!filters.city.includes(rowCity)) return false;
        }
        
        // Store Code filter (case-insensitive)
        if (filters.storeCode && filters.storeCode.length > 0) {
          const rowStoreCode = (row["Store Code"] || '').toLowerCase().trim();
          const filterMatch = filters.storeCode.some(code => code.toLowerCase().trim() === rowStoreCode);
          if (!filterMatch) return false;
        }
        
        // Sentiment filter
        if (filters.sentiment && filters.sentiment.length > 0) {
          const rowSentiment = row.Sentiment || row.sentiment || '';
          if (!filters.sentiment.includes(rowSentiment)) return false;
        }
        
        return true;
      }) : [];
      
      if (data.length === 0) {
        console.log('? Data not loaded yet...');
      } else {
        console.log('? Total data records:', data.length);
        console.log('? Filtered records:', filteredData.length);
        console.log('?? Current Filters:', filters);
      }
      
      if (filteredData.length > 0) {
        console.log('? Sample filtered row:', filteredData[0]);
      }

      // Compute lowest-rated zone insight
      useEffect(() => {
        if (filteredData.length === 0) {
          setLowestZoneInsight({
            zone: 'N/A',
            avgRating: 'N/A',
            negativePercent: 0,
            reason: 'No data available'
          });
          return;
        }

        // Calculate average rating per zone AND negative sentiment percentage
        const zoneMetrics = {};
        filteredData.forEach(row => {
          const zone = row.Zone;
          if (!zoneMetrics[zone]) {
            zoneMetrics[zone] = { 
              total: 0, 
              count: 0, 
              negativeCount: 0,
              categories: {}
            };
          }
          zoneMetrics[zone].total += row["Customer Rating"];
          zoneMetrics[zone].count += 1;
          
          if (row.Sentiment === 'NEGATIVE') {
            zoneMetrics[zone].negativeCount += 1;
            const cat = row.ImprovementCategory || 'Other';
            zoneMetrics[zone].categories[cat] = (zoneMetrics[zone].categories[cat] || 0) + 1;
          }
        });

        // Get zones to consider (all zones from data, not just filter)
        const zonesToConsider = Object.keys(zoneMetrics);

        if (zonesToConsider.length === 0) {
          setLowestZoneInsight({
            zone: 'N/A',
            avgRating: 'N/A',
            negativePercent: 0,
            reason: 'No zones available'
          });
          return;
        }

        // Find lowest-rated zone
        let lowestZone = null;
        let lowestAvg = Infinity;
        zonesToConsider.forEach(zone => {
          const avg = zoneMetrics[zone].total / zoneMetrics[zone].count;
          if (avg < lowestAvg) {
            lowestAvg = avg;
            lowestZone = zone;
          }
        });

        if (!lowestZone) {
          setLowestZoneInsight({
            zone: 'N/A',
            avgRating: 'N/A',
            negativePercent: 0,
            reason: 'No valid ratings'
          });
          return;
        }

        // Calculate precise metrics for the lowest zone
        const zoneData = zoneMetrics[lowestZone];
        const negativePercent = ((zoneData.negativeCount / zoneData.count) * 100).toFixed(1);
        
        // Find top negative category
        const topCategory = Object.entries(zoneData.categories)
          .sort((a, b) => b[1] - a[1])[0];
        
        const reason = topCategory
          ? `${negativePercent}% negative sentiment driven by ${topCategory[0].toLowerCase()}`
          : `${negativePercent}% negative sentiment across multiple categories`;

        setLowestZoneInsight({
          zone: lowestZone,
          avgRating: lowestAvg.toFixed(1),
          negativePercent: negativePercent,
          reason
        });
      }, [filters.zone, filteredData]);

      // Getting unique filter options with dependencies
      const getUniqueOptions = (key) => {
        let filteredRows = data;

        // Apply Business Name filter - cascading effect
        if (filters.businessName && filters.businessName !== '' && key !== 'Business Name') {
          filteredRows = filteredRows.filter(row => {
            const rowBusiness = (row["Business Name"] || '').toLowerCase().trim();
            const filterBusiness = filters.businessName.toLowerCase().trim();
            return rowBusiness === filterBusiness;
          });
        }

        // Apply Zone filter for other dropdowns
        if (filters.zone && filters.zone.length > 0 && key !== 'Zone' && key !== 'Business Name') {
          filteredRows = filteredRows.filter(row => filters.zone.includes(row.Zone || row.zone || ''));
        }

        // Apply State filter for City, Store Code, etc.
        if (filters.state && filters.state.length > 0 && key !== 'Zone' && key !== 'State' && key !== 'Business Name') {
          filteredRows = filteredRows.filter(row => filters.state.includes(row.State || row.state || ''));
        }

        // Apply City filter for Store Code, ImprovementCategory, etc.
        if (filters.city && filters.city.length > 0 && key !== 'Zone' && key !== 'State' && key !== 'City' && key !== 'Business Name') {
          filteredRows = filteredRows.filter(row => filters.city.includes(row.City || row.city || ''));
        }

        // Apply Store Code filter to cascade other filters
        if (filters.storeCode && filters.storeCode.length > 0 && key !== 'Store Code' && key !== 'Business Name') {
          filteredRows = filteredRows.filter(row => {
            const rowStoreCode = (row["Store Code"] || '').toLowerCase().trim();
            return filters.storeCode.some(code => code.toLowerCase().trim() === rowStoreCode);
          });
        }

        // For Business Name, normalize case and deduplicate
        if (key === 'Business Name') {
          const normalizedMap = {};
          filteredRows.forEach(row => {
            const name = row[key];
            if (name) {
              const normalizedKey = name.toLowerCase().trim();
              if (!normalizedMap[normalizedKey]) {
                normalizedMap[normalizedKey] = name; // Keep original case of first occurrence
              }
            }
          });
          return Object.values(normalizedMap).sort();
        }

        // For Store Code, use store master lookup but filtered by brand/zone/city
        if (key === 'Store Code') {
          // Start with all store codes from master
          let storeCodesFromMaster = Object.keys(storeMasterLookupRef.current || {})
            .filter(code => code && code !== 'UNKNOWN')
            .sort();
          
          // If brand is selected, only show stores carrying that brand
          if (filters.businessName && filters.businessName !== '') {
            storeCodesFromMaster = storeCodesFromMaster.filter(code => {
              const storeData = filteredRows.find(row => (row["Store Code"] || '').toLowerCase().trim() === code.toLowerCase().trim());
              if (!storeData) return false;
              const rowBusiness = (storeData["Business Name"] || '').toLowerCase().trim();
              const filterBusiness = filters.businessName.toLowerCase().trim();
              return rowBusiness === filterBusiness;
            });
          }
          
          console.log(`📊 Store Code filter: returning ${storeCodesFromMaster.length} codes (filtered by brand: ${filters.businessName})`);
          return storeCodesFromMaster;
        }

        // For Zone, City, State - return options based on filtered data
        if (key === 'Zone') {
          return [...new Set(filteredRows.map(row => row.Zone || row.zone || '').filter(val => val))].sort();
        }

        if (key === 'State') {
          return [...new Set(filteredRows.map(row => row.State || row.state || '').filter(val => val))].sort();
        }

        if (key === 'City') {
          return [...new Set(filteredRows.map(row => row.City || row.city || '').filter(val => val))].sort();
        }

        return [...new Set(filteredRows.map(row => row[key]).filter(val => val))].sort();
      };

      // Calculating KPIs
      const totalReviews = filteredData.length;
      
      // Debug: Check actual data state
      console.log('?? DATA STATE CHECK:');
      console.log('  data array length:', data.length);
      console.log('  filteredData length:', filteredData.length);
      console.log('  filters:', filters);
      
      if (totalReviews === 0 && data.length > 0) {
        console.warn('??WARNING: Data loaded (', data.length, 'rows) but filteredData is empty!');
        console.log('First raw data row:', data[0]);
      }
      
      const negativeReviews = filteredData.filter(row => row.Sentiment === 'NEGATIVE').length;
      const percentNegative = totalReviews > 0 ? ((negativeReviews / totalReviews) * 100).toFixed(1) : 0;
      
      console.log('?? Dashboard Metrics:');
      console.log('  Total Filtered Reviews:', totalReviews);
      console.log('  Negative Reviews:', negativeReviews);
      console.log('  % Negative:', percentNegative);
      
      // Handle empty data gracefully
      const storeRatings = {};
      const storeAvgRatings = [];
      
      if (totalReviews > 0) {
        filteredData.forEach(row => {
          const store = row["Store Code"] || 'Unknown';
          const rating = parseInt(row["Customer Rating"]) || 0;
          if (!storeRatings[store]) {
            storeRatings[store] = { total: 0, count: 0 };
          }
          storeRatings[store].total += rating;
          storeRatings[store].count += 1;
        });
        
        Object.entries(storeRatings).forEach(([store, { total, count }]) => {
          storeAvgRatings.push({
            store,
            avg: parseFloat((total / count).toFixed(2))
          });
        });
      }
      
      const bestStore = storeAvgRatings.length > 0 
        ? storeAvgRatings.sort((a, b) => b.avg - a.avg)[0] 
        : { store: 'N/A', avg: 0 };
      
      const worstStore = storeAvgRatings.length > 0 
        ? storeAvgRatings.sort((a, b) => a.avg - b.avg)[0] 
        : { store: 'N/A', avg: 0 };

      console.log('  Best Store:', bestStore);
      console.log('  Worst Store:', worstStore);

      // Preparing data for charts
      const sentimentCounts = {};
      filteredData.forEach(row => {
        const sentiment = row.Sentiment || 'UNKNOWN';
        sentimentCounts[sentiment] = (sentimentCounts[sentiment] || 0) + 1;
      });
      
      console.log('  Sentiment Distribution:', sentimentCounts);

      const categoryCounts = {};
      filteredData.forEach(row => {
        const cat = row.ImprovementCategory || 'Other';
        categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
      });
      
      const categoryData = Object.entries(categoryCounts)
        .map(([name, value]) => ({ name, value }))
        .sort((a, b) => b.value - a.value);
      
      console.log('  Category Data:', categoryData);

      const maxCategoryValue = categoryData.length > 0 ? Math.max(...categoryData.map(d => d.value)) : 0;
      const yAxisMax = maxCategoryValue > 0 ? maxCategoryValue + 100 : 1000;

      // Count emotion keywords from all comments - with type classification
      const allEmotionKeywords = {
        // Positive emotions
        'great': 'positive', 'excellent': 'positive', 'superb': 'positive', 'outstanding': 'positive', 'wonderful': 'positive', 'fantastic': 'positive', 'awesome': 'positive', 'impressed': 'positive', 'satisfied': 'positive', 'pleased': 'positive', 'brilliant': 'positive', 'perfect': 'positive', 'flawless': 'positive', 'remarkable': 'positive',
        'good': 'positive', 'nice': 'positive', 'pleasant': 'positive', 'delighted': 'positive', 'happy': 'positive', 'glad': 'positive', 'cheerful': 'positive', 'enjoyable': 'positive', 'satisfactory': 'positive',
        'thank': 'positive', 'grateful': 'positive', 'appreciate': 'positive', 'appreciated': 'positive', 'thanks': 'positive', 'thankful': 'positive', 'kudos': 'positive', 'respect': 'positive',
        'love': 'positive', 'loved': 'positive', 'adore': 'positive', 'amazing': 'positive', 'incredible': 'positive', 'delightful': 'positive', 'favorite': 'positive',
        'trust': 'positive', 'reliable': 'positive', 'dependable': 'positive', 'consistent': 'positive', 'confidence': 'positive', 'assured': 'positive', 'professional': 'positive', 'trustworthy': 'positive',
        // Negative emotions
        'rude': 'negative', 'unprofessional': 'negative', 'awful': 'negative', 'disrespectful': 'negative', 'impolite': 'negative', 'unfriendly': 'negative', 'arrogant': 'negative', 'hostile': 'negative', 'unpleasant': 'negative', 'frustrating': 'negative', 'frustrated': 'negative', 'irritating': 'negative', 'annoying': 'negative', 'insulted': 'negative',
        'disappointed': 'negative', 'disappointing': 'negative', 'poor': 'negative', 'bad': 'negative', 'terrible': 'negative', 'worst': 'negative', 'pathetic': 'negative', 'horrible': 'negative', 'disgusting': 'negative',
        'angry': 'negative', 'anger': 'negative', 'furious': 'negative', 'rage': 'negative', 'enraged': 'negative', 'upset': 'negative', 'mad': 'negative', 'infuriated': 'negative', 'disgusted': 'negative', 'hate': 'negative', 'hated': 'negative', 'despise': 'negative',
        'confused': 'negative', 'confusion': 'negative', 'unclear': 'negative', 'confusing': 'negative', 'complicated': 'negative', 'uncertain': 'negative', 'puzzled': 'negative', 'bewildered': 'negative',
        'sad': 'negative', 'sadness': 'negative', 'unhappy': 'negative', 'depressed': 'negative', 'regret': 'negative', 'regretted': 'negative', 'sorry': 'negative', 'ashamed': 'negative', 'dismayed': 'negative', 'disheartened': 'negative'
      };
      
      // Count keyword occurrences in all comments with type
      const keywordCountsObj = {};
      filteredData.forEach(row => {
        const comment = (row['Customer Response'] || '').toLowerCase();
        Object.entries(allEmotionKeywords).forEach(([keyword, type]) => {
          if (comment.includes(keyword)) {
            if (!keywordCountsObj[keyword]) {
              keywordCountsObj[keyword] = { count: 0, type };
            }
            keywordCountsObj[keyword].count++;
          }
        });
      });
      
      // Filter out zero-count keywords and sort by frequency
      const keywordCounts = Object.entries(keywordCountsObj)
        .filter(([word, data]) => data.count > 0)
        .sort((a, b) => b[1].count - a[1].count);
      
      const maxCount = keywordCounts.length > 0 ? keywordCounts[0][1].count : 1;
      const minFontSize = 12;
      const maxFontSize = 32;
      
      // Get color based on emotion type
      const getEmotionColor = (type) => {
        switch(type) {
          case 'positive': return COLORS.POSITIVE;
          case 'negative': return COLORS.NEGATIVE;
          default: return COLORS.NEUTRAL;
        }
      };
      
      const emotionData = keywordCounts.map(([word, data]) => ({
        name: word,
        count: data.count,
        type: data.type,
        color: getEmotionColor(data.type),
        fontSize: Math.min(maxFontSize, Math.max(minFontSize, minFontSize + (data.count / maxCount) * (maxFontSize - minFontSize)))
      }));

      const sentimentByZone = {};
      filteredData.forEach(row => {
        const zone = row.Zone;
        if (!sentimentByZone[zone]) {
          sentimentByZone[zone] = { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
        }
        sentimentByZone[zone][row.Sentiment]++;
      });
      const zoneData = Object.entries(sentimentByZone).map(([zone, counts]) => ({
        zone,
        ...counts
      }));

      const sentimentTrend = {};
      filteredData.forEach(row => {
        const month = row.Month;
        if (!sentimentTrend[month]) {
          sentimentTrend[month] = { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
        }
        sentimentTrend[month][row.Sentiment]++;
      });
      const trendData = Object.entries(sentimentTrend).map(([month, counts]) => ({
        month,
        ...counts
      }));

      const heatmapData = {};
      const topStores = Object.entries(
        filteredData.reduce((acc, row) => {
          acc[row["Store Code"]] = (acc[row["Store Code"]] || 0) + 1;
          return acc;
        }, {})
      )
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([store]) => store);

      topStores.forEach(store => {
        heatmapData[store] = {};
        filteredData
          .filter(row => row["Store Code"] === store)
          .forEach(row => {
            const cat = row.ImprovementCategory;
            if (!heatmapData[store][cat]) {
              heatmapData[store][cat] = { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
            }
            heatmapData[store][cat][row.Sentiment]++;
          });
      });

      const heatmapChartData = topStores.map(store => {
        const row = { store };
        Object.keys(categoryCounts).forEach(cat => {
          const sentiments = heatmapData[store][cat] || { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
          const total = sentiments.POSITIVE + sentiments.NEGATIVE + sentiments.NEUTRAL;
          if (total === 0) {
            row[cat] = { count: 0, sentiment: 'NONE' };
          } else {
            const maxSentiment = sentiments.POSITIVE >= sentiments.NEGATIVE && sentiments.POSITIVE >= sentiments.NEUTRAL
              ? 'POSITIVE'
              : sentiments.NEGATIVE >= sentiments.POSITIVE && sentiments.NEGATIVE >= sentiments.NEUTRAL
              ? 'NEGATIVE'
              : 'NEUTRAL';
            row[cat] = {
              count: total,
              sentiment: maxSentiment,
              percent: {
                POSITIVE: ((sentiments.POSITIVE / total) * 100).toFixed(1),
                NEGATIVE: ((sentiments.NEGATIVE / total) * 100).toFixed(1),
                NEUTRAL: ((sentiments.NEUTRAL / total) * 100).toFixed(1)
              },
              sample: filteredData.find(r => r["Store Code"] === store && r.ImprovementCategory === cat)?.["Customer Response"] || ''
            };
          }
        });
        return row;
      });

      // Normalize city names
      const normalizeCityName = (city) => {
        if (!city) return 'N/A';
        const cityMap = {
          'Bangaluru': 'Bengaluru',
          'bangaluru': 'Bengaluru',
          'BANGALURU': 'Bengaluru',
          'Bangalore': 'Bengaluru',
          'bangalore': 'Bengaluru',
          'BANGALORE': 'Bengaluru'
        };
        return cityMap[city] || city;
      };

      // Exact keywords that define each sub-driver category
      const subDriverKeywords = {
        'Staff Behaviour & Attitude': {
          positive: ['courteous', 'courtesy', 'excellent staff', 'friendly', 'kind', 'polite', 'polite staff', 'professionalism', 'respectful', 'very kind', 'good staff', 'helpful', 'welcoming staff'],
          negative: ['arrogant', 'attitude', 'bad attitude', 'behavior', 'behaviour', 'rude', 'rude staff', 'unprofessional', 'unprofessional behavior', 'poor attitude', 'bad behavior'],
          neutral: ['manner', 'salesman', 'salesperson', 'staff', 'behavior']
        },
        'Service Speed & Wait Time': {
          positive: ['fast', 'efficient', 'quick', 'prompt service', 'no wait'],
          negative: ['busy', 'crowd', 'delay', 'long wait', 'slow', 'slow service', 'wait', 'waiting', 'crowded'],
          neutral: ['line', 'service time']
        },
        'Billing, Payment & Transaction': {
          positive: ['smooth billing', 'easy payment', 'quick checkout'],
          negative: ['billing', 'billing mistake', 'charge', 'payment failed', 'wrong billing', 'overcharge', 'incorrect billing'],
          neutral: ['invoice', 'payment', 'receipt', 'transaction']
        },
        'In-Store Service & Interaction': {
          positive: ['good service', 'excellent service', 'hospitality', 'interaction', 'service', 'helpful service'],
          negative: ['poor service', 'bad service', 'no service', 'ignored'],
          neutral: ['interaction', 'service']
        },
        'Store Ambience & Cleanliness': {
          positive: ['ambiance', 'atmosphere', 'cleanliness', 'organized', 'pleasant visit', 'store was clean', 'welcoming', 'clean', 'beautiful', 'nice ambiance'],
          negative: ['dirty', 'disorganized', 'messy', 'unclean', 'cluttered', 'poor ambiance', 'bad atmosphere', 'poorly maintained'],
          neutral: ['in-store', 'store environment']
        }
      };

      // Get keywords and count for sub-driver sentiment popup
      const getSubDriverKeywords = (subDriver, sentiment) => {
        // Get the predefined keywords for this sub-driver
        const subDriverData = subDriverKeywords[subDriver];
        if (!subDriverData) {
          return { keywords: [], count: 0, reviewCount: 0 };
        }
        
        // Get keywords for the requested sentiment
        let sentimentKeywords = [];
        if (sentiment === 'Positive') {
          sentimentKeywords = subDriverData.positive || [];
        } else if (sentiment === 'Negative') {
          sentimentKeywords = subDriverData.negative || [];
        } else if (sentiment === 'Neutral') {
          sentimentKeywords = subDriverData.neutral || [];
        } else {
          // For 'All', combine all keywords
          sentimentKeywords = [...(subDriverData.positive || []), ...(subDriverData.negative || []), ...(subDriverData.neutral || [])];
        }

        // Filter reviews matching the sub-driver and sentiment
        const matchingReviews = filteredData.filter(row => 
          row.SubDriver === subDriver && 
          row.ImprovementCategory === 'Store Experience'
        );

        // Further filter by sentiment
        let sentimentReviews = [];
        if (sentiment === 'Positive') {
          sentimentReviews = matchingReviews.filter(row => 
            ['Joy', 'Satisfaction', 'Happy', 'Gratitude', 'Trust'].includes(row.Emotion)
          );
        } else if (sentiment === 'Negative') {
          sentimentReviews = matchingReviews.filter(row => 
            ['Anger', 'Disappointment', 'Frustration', 'Sadness', 'Confusion'].includes(row.Emotion)
          );
        } else {
          sentimentReviews = matchingReviews.filter(row => {
            const neutralEmotions = ['Joy', 'Satisfaction', 'Happy', 'Gratitude', 'Trust', 'Anger', 'Disappointment', 'Frustration', 'Sadness', 'Confusion'];
            return !neutralEmotions.includes(row.Emotion);
          });
        }

        // Count reviews that contain these keywords
        let keywordMatchCount = 0;
        sentimentReviews.forEach(review => {
          const text = (review["Customer Response"] || '').toLowerCase();
          const hasKeyword = sentimentKeywords.some(keyword => text.includes(keyword.toLowerCase()));
          if (hasKeyword) {
            keywordMatchCount++;
          }
        });

        return {
          keywords: sentimentKeywords,
          count: sentimentKeywords.length,
          reviewCount: sentimentReviews.length,
          keywordMatchCount: keywordMatchCount
        };
      };

      // Calculate insights data
      const storeExpPercent = totalReviews > 0
        ? ((categoryCounts['Store Experience'] || 0) / totalReviews * 100).toFixed(1)
        : 0;

      const lowRatedStores = storeAvgRatings
        .filter(s => s.avg <= 3.6 && s.store !== 'N/A')
        .map(s => s.store)
        .slice(0, 2)
        .join(' & ') || 'None';

      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const recentPositive = filteredData.filter(row => 
        row.Sentiment === 'POSITIVE' && new Date(row["Comment Date_NEW"]) >= thirtyDaysAgo
      ).length;
      const priorPositive = filteredData.filter(row => 
        row.Sentiment === 'POSITIVE' && new Date(row["Comment Date_NEW"]) < thirtyDaysAgo
      ).length;
      const positiveGrowth = priorPositive > 0
        ? ((recentPositive - priorPositive) / priorPositive * 100).toFixed(1)
        : recentPositive > 0 ? 100 : 0;

      const cityReviewCounts = filteredData.reduce((acc, row) => {
        const city = row.City;
        acc[city] = (acc[city] || 0) + 1;
        return acc;
      }, {});
      const topCities = Object.entries(cityReviewCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2)
        .map(([city]) => normalizeCityName(city))
        .join(' & ') || 'None';

      const bestStoreInfo = bestStore.store !== 'N/A' 
        ? `${bestStore.store} (${bestStore.avg.toFixed(1)})` 
        : 'None';

      // Handling filter changes
      const handleFilterChange = (key, value) => {
        setFilters(prev => {
          let newFilters = { ...prev };

          if (key === 'businessName') {
            newFilters[key] = value;
            // Reset dependent filters
            newFilters.zone = [];
            newFilters.state = [];
            newFilters.city = [];
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
            return newFilters;
          }

          // Handle checkbox filters
          const newValues = prev[key].includes(value)
            ? prev[key].filter(v => v !== value)
            : [...prev[key], value];
          newFilters[key] = newValues;

          // Reset dependent filters based on the changed filter
          if (key === 'zone') {
            newFilters.state = [];
            newFilters.city = [];
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
          } else if (key === 'state') {
            newFilters.city = [];
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
          } else if (key === 'city') {
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
          }

          return newFilters;
        });
      };

      // Handle chart interactions
      const handlePieClick = (data) => {
        if (data && data.name) {
          handleFilterChange('sentiment', data.name);
        }
      };

      const handleBarClick = (data, chartType) => {
        if (data) {
          if (chartType === 'category' && data.name) {
            // If clicking Store Experience, show sub-drivers instead of filtering
            if (data.name === 'Store Experience') {
              setShowSubDrivers(true);
              setSelectedKeyDriver(data.name);
            } else {
              // For other categories, apply filter as normal
              handleFilterChange('ImprovementCategory', data.name);
            }
          } else if (chartType === 'zone' && data.zone) {
            handleFilterChange('zone', data.zone);
          }
        }
      };

      const handleHeatmapClick = (store, category) => {
        setFilters(prev => ({
          ...prev,
          storeCode: [store],
          ImprovementCategory: [category]
        }));
      };

      const resetFilters = () => {
        setFilters({
          businessName: '', // Empty = show all brands
          zone: [],
          state: [],
          city: [],
          storeCode: [],
          mallHS: [],
          sentiment: [],
          financialYear: [],
          quarter: [],
          month: [],
          ImprovementCategory: []
        });
        setFilterSearch({});
      };

      // Handle filter search
      const handleFilterSearch = (key, value) => {
        setFilterSearch(prev => ({ ...prev, [key]: value }));
      };

      // Get filtered options based on search
      const getFilteredOptions = (key, options) => {
        const search = filterSearch[key]?.toLowerCase() || '';
        return options.filter(opt => opt.toLowerCase().includes(search));
      };

      // Shortened category names for heatmap
      const shortenCategoryName = (cat) => {
        return cat === 'Customer Support' ? 'Cust Support' :
               cat === 'Pricing & Discounts' ? 'Pricing' :
               cat === 'Product Assortment' ? 'Assortment' :
               cat === 'Product Quality' ? 'Quality' :
               cat === 'Promotions & Offers' ? 'Promotions' :
               cat === 'Return & Refund Policies' ? 'Returns' :
               cat === 'Store Experience' ? 'Store Exp' : cat;
      };

      // Format X-axis labels with specified short names and line breaks
      const formatXAxisLabel = (label) => {
        switch (label) {
          case 'Customer Support': return 'Cust<br>Support';
          case 'Pricing & Discounts': return 'Pricing';
          case 'Product Assortment': return 'Assort<br>ment';
          case 'Product Quality': return 'Quality';
          case 'Promotions & Offers': return 'Promo<br>tions';
          case 'Return & Refund Policies': return 'Returns';
          case 'Store Experience': return 'Store<br>Exp';
          default: return label;
        }
      };

      // Custom tick component for X-axis
      const CustomXAxisTick = ({ x, y, payload }) => {
        const formattedLabel = formatXAxisLabel(payload.value);
        return (
          <g transform={`translate(${x},${y})`}>
            <text
              x={0}
              y={0}
              dy={16}
              className="custom-x-axis-label"
              textAnchor="middle"
              dangerouslySetInnerHTML={{ __html: formattedLabel.replace('<br>', '\n') }}
            />
          </g>
        );
      };
      // Rendering the dashboard
      return (
        <div className="border-4 border-gray-200 rounded-lg p-6 bg-white">
          <div className="container mx-auto">
            {/* Dashboard Heading */}
            <div className="bg-gradient-to-b from-slate-900 to-slate-800 text-white p-8 rounded-lg mb-8 shadow-2xl border-l-8 border-amber-500">
              <h1 className="text-5xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-white to-gray-300">Voice of Customers Dashboard</h1>
              <div className="grid grid-cols-3 gap-6">
                <div className="bg-white/10 backdrop-blur p-4 rounded-lg border border-white/20">
                  <span className="text-gray-300 text-sm font-semibold">MIN REVIEW DATE</span>
                  <p className="text-2xl font-bold text-amber-400 mt-2">{data.length > 0 ? new Date(Math.min(...data.map(d => new Date(d['Comment Date_NEW'])))).toLocaleDateString('en-US', {year: 'numeric', month: 'short', day: 'numeric'}) : 'N/A'}</p>
                </div>
                <div className="bg-white/10 backdrop-blur p-4 rounded-lg border border-white/20">
                  <span className="text-gray-300 text-sm font-semibold">MAX REVIEW DATE</span>
                  <p className="text-2xl font-bold text-amber-400 mt-2">{data.length > 0 ? new Date(Math.max(...data.map(d => new Date(d['Comment Date_NEW'])))).toLocaleDateString('en-US', {year: 'numeric', month: 'short', day: 'numeric'}) : 'N/A'}</p>
                </div>
                <div className="bg-white/10 backdrop-blur p-4 rounded-lg border border-white/20">
                  <span className="text-gray-300 text-sm font-semibold">TOTAL RECORDS</span>
                  <p className="text-2xl font-bold text-amber-400 mt-2">{data.length.toLocaleString()}</p>
                </div>
              </div>
            </div>
          
          {/* Loading State */}
          {isLoading && (
            <div className="flex justify-center items-center py-12">
              <div className="text-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
                <p className="text-gray-600">Loading data from GitHub...</p>
                {mlSentimentStatus !== 'not-started' && (
                  <div className="mt-4 text-sm">
                    {mlSentimentStatus === 'analyzing' && <p className="text-blue-600">?? Analyzing sentiment with ML model...</p>}
                    {mlSentimentStatus === 'completed' && <p className="text-green-600">? ML sentiment analysis complete</p>}
                    {mlSentimentStatus === 'unavailable' && <p className="text-amber-600">?? ML API unavailable - using original sentiment</p>}
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Error State */}
          {loadError && (
            <div className="bg-red-50 border-l-4 border-red-500 p-4 mb-4 rounded">
              <p className="text-red-800"><strong>Error:</strong> {loadError}</p>
              <p className="text-red-700 text-sm mt-2">
                Please ensure:
                <ul className="list-disc ml-6 mt-1">
                  <li>GitHub repo "{GITHUB_CONFIG.repo}" exists and is public</li>
                  <li>CSV files "reviews.csv" and "stores_master.csv" exist in the repo</li>
                  <li>Files are in the "{GITHUB_CONFIG.branch}" branch</li>
                  <li>You have an active internet connection</li>
                </ul>
              </p>
            </div>
          )}

          {/* Main Dashboard - Only show if data loaded successfully */}
          {!isLoading && !loadError && data.length > 0 && (
            <>
              {/* Toggling filter drawer */}
              <button
                className="bg-gray-800 text-white px-4 py-2 rounded mb-4"
                onClick={() => setShowFilters(!showFilters)}
              >
                {showFilters ? 'Hide Filters' : 'Show Filters'}
              </button>

              <div className="flex">
            {/* Filter Drawer */}
            {showFilters && (
              <div className="filter-drawer w-64 bg-white p-4 rounded shadow mr-4">
                <h2 className="text-lg font-bold mb-4">Filters</h2>
                <button
                  className="bg-red-500 text-white px-2 py-1 rounded mb-4"
                  onClick={resetFilters}
                >
                  Reset Filters
                </button>

                {/* Business Name Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Brand</h3>
                  <select
                    className="w-full p-2 border rounded"
                    value={filters.businessName}
                    onChange={(e) => handleFilterChange('businessName', e.target.value)}
                  >
                    {getUniqueOptions('Business Name').map(option => (
                      <option key={option} value={option}>{option}</option>
                    ))}
                  </select>
                </div>

                {/* Zone Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Zone</h3>
                  <input
                    type="text"
                    placeholder="Search Zone"
                    className="filter-search"
                    value={filterSearch.zone || ''}
                    onChange={(e) => handleFilterSearch('zone', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('zone', getUniqueOptions('Zone')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.zone.includes(option)}
                          onChange={() => handleFilterChange('zone', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* State Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">State</h3>
                  <input
                    type="text"
                    placeholder="Search State"
                    className="filter-search"
                    value={filterSearch.state || ''}
                    onChange={(e) => handleFilterSearch('state', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('state', getUniqueOptions('State')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.state.includes(option)}
                          onChange={() => handleFilterChange('state', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* City Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">City</h3>
                  <input
                    type="text"
                    placeholder="Search City"
                    className="filter-search"
                    value={filterSearch.city || ''}
                    onChange={(e) => handleFilterSearch('city', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('city', getUniqueOptions('City')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.city.includes(option)}
                          onChange={() => handleFilterChange('city', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Store Code Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Store Code</h3>
                  <input
                    type="text"
                    placeholder="Search Store Code"
                    className="filter-search"
                    value={filterSearch.storeCode || ''}
                    onChange={(e) => handleFilterSearch('storeCode', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('storeCode', getUniqueOptions('Store Code')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.storeCode.includes(option)}
                          onChange={() => handleFilterChange('storeCode', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Mall/HS Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Mall/HS</h3>
                  <input
                    type="text"
                    placeholder="Search Mall/HS"
                    className="filter-search"
                    value={filterSearch.mallHS || ''}
                    onChange={(e) => handleFilterSearch('mallHS', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('mallHS', getUniqueOptions('Mall/HS')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.mallHS.includes(option)}
                          onChange={() => handleFilterChange('mallHS', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Sentiment Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Sentiment</h3>
                  <input
                    type="text"
                    placeholder="Search Sentiment"
                    className="filter-search"
                    value={filterSearch.sentiment || ''}
                    onChange={(e) => handleFilterSearch('sentiment', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('sentiment', ['POSITIVE', 'NEGATIVE', 'NEUTRAL']).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.sentiment.includes(option)}
                          onChange={() => handleFilterChange('sentiment', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option.charAt(0) + option.slice(1).toLowerCase()}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Themes (ImprovementCategory) Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Themes</h3>
                  <input
                    type="text"
                    placeholder="Search Themes"
                    className="filter-search"
                    value={filterSearch.ImprovementCategory || ''}
                    onChange={(e) => handleFilterSearch('ImprovementCategory', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('ImprovementCategory', getUniqueOptions('ImprovementCategory')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.ImprovementCategory.includes(option)}
                          onChange={() => handleFilterChange('ImprovementCategory', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Financial Year Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Financial Year</h3>
                  <input
                    type="text"
                    placeholder="Search Financial Year"
                    className="filter-search"
                    value={filterSearch.financialYear || ''}
                    onChange={(e) => handleFilterSearch('financialYear', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('financialYear', getUniqueOptions('FY')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.financialYear.includes(option)}
                          onChange={() => handleFilterChange('financialYear', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Quarter Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Quarter</h3>
                  <p className="text-xs text-gray-500 mb-2">Fiscal Year (Apr-Mar)</p>
                  <input
                    type="text"
                    placeholder="Search Quarter"
                    className="filter-search"
                    value={filterSearch.quarter || ''}
                    onChange={(e) => handleFilterSearch('quarter', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('quarter', getUniqueOptions('Quarter')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.quarter.includes(option)}
                          onChange={() => handleFilterChange('quarter', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Month Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Month</h3>
                  <input
                    type="text"
                    placeholder="Search Month"
                    className="filter-search"
                    value={filterSearch.month || ''}
                    onChange={(e) => handleFilterSearch('month', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('month', getUniqueOptions('Month')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.month.includes(option)}
                          onChange={() => handleFilterChange('month', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            <div className="flex-1">
              {/* Executive Snapshot KPIs */}
              <div className="grid grid-cols-4 gap-4 mb-8">
                <div className="kpi-card bg-gradient-to-r from-gray-200 to-gray-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">Total Reviews</h3>
                  <p className="text-2xl">{totalReviews}</p>
                </div>
                <div className="kpi-card bg-gradient-to-r from-red-200 to-red-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">% Negative</h3>
                  <p className="text-2xl">{percentNegative}%</p>
                </div>
                <div className="kpi-card bg-gradient-to-r from-green-200 to-green-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">Best Store</h3>
                  <p className="text-2xl">{bestStore.store} ({bestStore.avg.toFixed(1)})</p>
                </div>
                <div className="kpi-card bg-gradient-to-r from-yellow-200 to-yellow-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">Lowest Rated Store</h3>
                  <p className="text-2xl">{worstStore.store} ({worstStore.avg.toFixed(1)})</p>
                </div>
              </div>

              {/* Strategic Insights */}
              <div className="mb-8">
                <h2 className="text-xl font-bold mb-4">Strategic Insights</h2>
                <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
                  {/* Theme to Prioritize */}
                  <div className="insight-card bg-gray-100 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">📊</span>
                      <h3 className="text-lg font-bold text-gray-800">Store Experience Dominates</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Dominates {storeExpPercent}% of feedback across all reviews. Primary driver of both customer praise and complaints.
                    </p>
                  </div>

                  {/* Zone Sentiment Dip */}
                  <div className="insight-card bg-red-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2 text-red-600">📉</span>
                      <h3 className="text-lg font-bold text-gray-800">{lowestZoneInsight.zone} Sentiment Dip</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Average rating: {lowestZoneInsight.avgRating}/5 - {lowestZoneInsight.reason}.
                    </p>
                  </div>

                  {/* Underperforming Stores */}
                  <div className="insight-card bg-yellow-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">⚠️</span>
                      <h3 className="text-lg font-bold text-gray-800">Stores Needing Urgent Attention</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      {lowRatedStores} store{lowRatedStores !== 1 ? 's' : ''} rated =3.6 demand immediate intervention. Store Experience is key issue.
                    </p>
                  </div>

                  {/* Positive Momentum */}
                  <div className="insight-card bg-green-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2 text-green-600">📈</span>
                      <h3 className="text-lg font-bold text-gray-800">Positive Feedback Surge</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Positive reviews grew by {positiveGrowth}% YoY. Leading indicator of improving customer satisfaction across Metro zones.
                    </p>
                  </div>

                  {/* High Review Volume Cities */}
                  <div className="insight-card bg-blue-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">🎯</span>
                      <h3 className="text-lg font-bold text-gray-800">Priority Cities</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      {topCities} account for highest review volume. Critical zones for intervention and scaling successful initiatives.
                    </p>
                  </div>

                  {/* Best Store */}
                  <div className="insight-card bg-teal-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">⭐</span>
                      <h3 className="text-lg font-bold text-gray-800">Leading Store Performance</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Store {bestStoreInfo} and its regional cluster lead on service 🚀 potential model for scaling excellence.
                    </p>
                  </div>
                </div>
              </div>

              {/* Row 1: Key Drivers / Sub-Drivers Chart (Conditional View Switch) */}
              <div className="mb-8">
                {/* Sub-Drivers View */}
                {showSubDrivers && selectedKeyDriver === 'Store Experience' ? (
                  <>
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="chart-title">📊 Store Experience Sub-Drivers</h2>
                      <button
                        onClick={() => {
                          setShowSubDrivers(false);
                          setSelectedKeyDriver(null);
                        }}
                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-semibold"
                      >
                        ⬅️ Back to Key Drivers
                      </button>
                    </div>
                    <ResponsiveContainer width="100%" height={300}>
                      <BarChart
                        data={(() => {
                          const subDriverData = {};
                          filteredData
                            .filter(row => row.ImprovementCategory === 'Store Experience' && row.SubDriver)
                            .forEach(row => {
                              const subDriver = row.SubDriver;
                              const emotion = row.Emotion || 'Neutral';
                              if (!subDriverData[subDriver]) {
                                subDriverData[subDriver] = { 
                                  name: subDriver, 
                                  total: 0,
                                  'Neutral': 0,
                                  'Positive': 0,
                                  'Negative': 0
                                };
                              }
                              subDriverData[subDriver].total++;
                              
                              // Categorize emotions
                              if (['Joy', 'Satisfaction', 'Happy', 'Gratitude', 'Trust'].includes(emotion)) {
                                subDriverData[subDriver]['Positive']++;
                              } else if (['Anger', 'Disappointment', 'Frustration', 'Sadness', 'Confusion'].includes(emotion)) {
                                subDriverData[subDriver]['Negative']++;
                              } else {
                                subDriverData[subDriver]['Neutral']++;
                              }
                            });
                          
                          // Calculate percentages - ensure they add up to 100%
                          return Object.values(subDriverData)
                            .sort((a, b) => b.total - a.total)
                            .map(driver => {
                              let neutral = driver.total > 0 ? Math.floor((driver['Neutral'] / driver.total) * 100) : 0;
                              let positive = driver.total > 0 ? Math.floor((driver['Positive'] / driver.total) * 100) : 0;
                              let negative = driver.total > 0 ? Math.floor((driver['Negative'] / driver.total) * 100) : 0;
                              
                              // Fix rounding: if sum < 100, add remainder to largest segment
                              const sum = neutral + positive + negative;
                              if (sum < 100 && driver.total > 0) {
                                const remainder = 100 - sum;
                                if (neutral >= positive && neutral >= negative) {
                                  neutral += remainder;
                                } else if (positive >= negative) {
                                  positive += remainder;
                                } else {
                                  negative += remainder;
                                }
                              }
                              
                              return {
                                name: driver.name,
                                total: driver.total,
                                Neutral: neutral,
                                Positive: positive,
                                Negative: negative,
                                NeutralCount: driver['Neutral'],
                                PositiveCount: driver['Positive'],
                                NegativeCount: driver['Negative']
                              };
                            });
                        })()}
                        layout="vertical"
                        margin={{ top: 20, right: 30, left: 200, bottom: 20 }}
                        onClick={(state) => {
                          if (state.activePayload && state.activePayload.length > 0) {
                            const { dataKey, payload } = state.activePayload[0];
                            const subDriver = payload.name;
                            
                            // Get keywords for ALL sentiments, not just the one clicked
                            setKeywordPopup({
                              subDriver,
                              sentiment: 'All', // Show all sentiments
                              keywords: {
                                all: getSubDriverKeywords(subDriver, 'All'),
                                positive: getSubDriverKeywords(subDriver, 'Positive'),
                                negative: getSubDriverKeywords(subDriver, 'Negative'),
                                neutral: getSubDriverKeywords(subDriver, 'Neutral')
                              }
                            });
                          }
                        }}
                      >
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis type="number" domain={[0, 100]} label={{ value: '%', position: 'right', offset: 10 }} />
                        <YAxis dataKey="name" type="category" width={190} tick={{ fontSize: 12 }} />
                        <Tooltip 
                          formatter={(value, name) => {
                            if (name === 'Neutral') return `${value}%`;
                            if (name === 'Positive') return `${value}%`;
                            if (name === 'Negative') return `${value}%`;
                            return value;
                          }}
                          contentStyle={{ backgroundColor: '#fff', border: '1px solid #ccc', borderRadius: '4px' }}
                        />
                        <Bar dataKey="Neutral" stackId="emotion" fill="#fbbf24" name="Neutral">
                          <LabelList dataKey="Neutral" position="insideLeft" formatter={(value) => value > 5 ? `${value}%` : ''} fill="#fff" fontSize={12} fontWeight="bold" />
                        </Bar>
                        <Bar dataKey="Positive" stackId="emotion" fill="#10b981" name="Positive">
                          <LabelList dataKey="Positive" position="insideLeft" formatter={(value) => value > 5 ? `${value}%` : ''} fill="#fff" fontSize={12} fontWeight="bold" />
                        </Bar>
                        <Bar dataKey="Negative" stackId="emotion" fill="#ef4444" name="Negative">
                          <LabelList dataKey="Negative" position="insideLeft" formatter={(value) => value > 5 ? `${value}%` : ''} fill="#fff" fontSize={12} fontWeight="bold" />
                        </Bar>
                      </BarChart>
                    </ResponsiveContainer>
                  </>
                ) : (
                  /* Key Drivers View */
                  <>
                    <h2 className="chart-title">Key Drivers of Customer Feedback</h2>
                    <ResponsiveContainer width="100%" height={400}>
                      <BarChart
                        data={categoryData}
                        margin={{ top: 20, right: 30, left: 20, bottom: 50 }}
                        onClick={(data) => handleBarClick(data.activePayload?.[0]?.payload, 'category')}
                      >
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis
                          dataKey="name"
                          tick={<CustomXAxisTick />}
                          interval={0}
                          height={60}
                        />
                        <YAxis domain={[0, yAxisMax]} />
                        <Tooltip />
                        <Bar dataKey="value" fill="#10b981">
                          {categoryData.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={COLORS.POSITIVE} />
                          ))}
                          <LabelList dataKey="value" position="top" className="bar-label" />
                        </Bar>
                      </BarChart>
                    </ResponsiveContainer>
                  </>
                )}
              </div>

              {/* Row 2: Emotion Word Cloud and Sentiment Breakdown */}
              <div className="grid grid-cols-2 gap-4 mb-8">
                <div>
                  <h2 className="chart-title">Emotion Word Cloud</h2>
                  <div className="word-cloud" style={{ maxHeight: '350px', overflowY: 'auto', padding: '10px', border: '1px solid #e5e7eb', borderRadius: '8px' }}>
                    {emotionData.map(emotion => (
                      <span
                        key={emotion.name}
                        style={{
                          backgroundColor: emotion.color,
                          fontSize: `${emotion.fontSize}px`,
                          color: '#fff',
                          maxWidth: '150px',
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          display: 'inline-block',
                          padding: '6px 12px',
                          margin: '4px',
                          borderRadius: '20px',
                          fontWeight: '500'
                        }}
                      >
                        {emotion.name} ({emotion.count})
                      </span>
                    ))}
                  </div>
                  

                </div>
                <div>
                  <h2 className="chart-title">Sentiment Breakdown</h2>
                  <ResponsiveContainer width="100%" height={300}>
                    <PieChart>
                      <Pie
                        data={Object.entries(sentimentCounts).map(([name, value]) => ({ name, value }))}
                        cx="50%"
                        cy="50%"
                        labelLine={true}
                        label={({ percent }) => `${(percent * 100).toFixed(1)}%`}
                        outerRadius={80}
                        fill="#8884d8"
                        dataKey="value"
                        onClick={handlePieClick}
                      >
                        {Object.entries(sentimentCounts).map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={COLORS[entry[0]]} />
                        ))}
                      </Pie>
                      <Tooltip formatter={(value, name) => [value, name]} />
                      <Legend />
                    </PieChart>
                  </ResponsiveContainer>
                </div>
              </div>

              {/* Row 4: Heatmap and Sentiment by Zone */}
              <div className="grid grid-cols-2 gap-4 mb-8">
                <div className="heatmap-card">
                  <h2 className="chart-title">Store-wise Feedback Drivers Heatmap</h2>
                  <div className="overflow-x-auto">
                    <table className="w-full">
                      <thead>
                        <tr>
                          <th className="heatmap-cell font-semibold sticky left-0 bg-white z-10">Store</th>
                          {Object.keys(categoryCounts).map(cat => (
                            <th key={cat} className="heatmap-cell font-semibold">
                              {shortenCategoryName(cat)}
                            </th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {heatmapChartData.map(row => (
                          <tr key={row.store}>
                            <td className="heatmap-cell sticky left-0 bg-white z-10">{row.store}</td>
                            {Object.keys(categoryCounts).map(cat => {
                              const cell = row[cat] || { count: 0, sentiment: 'NONE' };
                              const bgColor = COLORS[cell.sentiment];
                              const textColor = cell.sentiment === 'NONE' ? '#000' : '#fff';
                              const indicator = cell.sentiment === 'POSITIVE' ? '👍' :
                                        cell.sentiment === 'NEGATIVE' ? '�' :
                                        cell.sentiment === 'NEUTRAL' ? '➖' : '';
                              const indicatorStyle = cell.sentiment === 'NEGATIVE' ? { 
                                color: '#fff'
                              } : {};
                              return (
                                <td
                                  className="heatmap-cell"
                                  style={{ backgroundColor: bgColor, color: textColor }}
                                  key={`${row.store}-${cat}`}
                                  title={
                                    cell.count > 0
                                      ? `Count: ${cell.count}\nPositive: ${cell.percent.POSITIVE}%\nNegative: ${cell.percent.NEGATIVE}%\nSample: ${cell.sample}`
                                      : ''
                                  }
                                  onClick={() => cell.count > 0 && handleHeatmapClick(row.store, cat)}
                                >
                                  {cell.count > 0 ? (
                                    <span style={indicatorStyle}>
                                      {cell.count} <span style={indicatorStyle}>{indicator}</span>
                                    </span>
                                  ) : (
                                    '-'
                                  )}
                                </td>
                              );
                            })}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                  <div className="flex justify-end mt-4 space-x-4">
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-teal-500 mr-2"></div> Positive
                    </div>
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-red-600 mr-2"></div> Negative
                    </div>
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-yellow-500 mr-2"></div> Neutral
                    </div>
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-gray-300 mr-2"></div> None
                    </div>
                  </div>
                </div>
                <div>
                  <h2 className="chart-title">Sentiment by Zone</h2>
                  <ResponsiveContainer width="100%" height={300}>
                    <BarChart
                      data={zoneData}
                      onClick={(data) => handleBarClick(data.activePayload?.[0]?.payload, 'zone')}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="zone" tick={{ fontSize: 12 }} />
                      <YAxis />
                      <Tooltip />
                      <Legend />
                      <Bar dataKey="POSITIVE" fill={COLORS.POSITIVE} />
                      <Bar dataKey="NEGATIVE" fill={COLORS.NEGATIVE} />
                      <Bar dataKey="NEUTRAL" fill={COLORS.NEUTRAL} />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </div>

              {/* Row 5: Comments Viewer */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <h2 className="chart-title">😊 Positive Comments (Top 15) By Date</h2>
                  <div className="max-h-96 overflow-y-auto">
                    {filteredData
                      .filter(row => row.Sentiment === 'POSITIVE')
                      .sort((a, b) => new Date(b["Comment Date_NEW"]) - new Date(a["Comment Date_NEW"]))
                      .slice(0, 15)
                      .map((row, index) => (
                        <div key={index} className="comment-card">
                          <p className="font-bold">😊 {row["Customer Response"]}</p>
                          <p className="comment-details">
                            Store: {row["Store Code"]} | Category: {row["ImprovementCategory"]}{row["SubDriver"] ? ` → ${row["SubDriver"]}` : ''}
                            <br/>
                            📅 <strong>{row["Comment Date_NEW"] ? new Date(row["Comment Date_NEW"]).toLocaleDateString('en-US', {year: 'numeric', month: 'short', day: 'numeric'}) : 'N/A'}</strong>
                          </p>
                        </div>
                      ))}
                  </div>
                </div>
                <div>
                  <h2 className="chart-title">😠 Negative Comments (Top 15) By Date</h2>
                  <div className="max-h-96 overflow-y-auto">
                    {filteredData
                      .filter(row => row.Sentiment === 'NEGATIVE')
                      .sort((a, b) => new Date(b["Comment Date_NEW"]) - new Date(a["Comment Date_NEW"]))
                      .slice(0, 15)
                      .map((row, index) => (
                        <div key={index} className="comment-card">
                          <p className="font-bold">😠 {row["Customer Response"]}</p>
                          <p className="comment-details">
                            Store: {row["Store Code"]} | Category: {row["ImprovementCategory"]}{row["SubDriver"] ? ` → ${row["SubDriver"]}` : ''} <br/>
                            📅 <strong>{row["Comment Date_NEW"] ? new Date(row["Comment Date_NEW"]).toLocaleDateString('en-US', {year: 'numeric', month: 'short', day: 'numeric'}) : 'N/A'}</strong>
                          </p>
                        </div>
                      ))}
                  </div>
                </div>
              </div>
            </div>
            </div>
            </>
          )}
          {/* No Data State */}
          {!isLoading && !loadError && data.length === 0 && (
            <div className="bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded">
              <p className="text-yellow-800"><strong>No data available</strong></p>
              <p className="text-yellow-700 text-sm mt-2">The CSV files were loaded but contain no valid records.</p>
            </div>
          )}

          {/* Keyword Popup Modal */}
          {keywordPopup && (
            <div 
              className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
              onClick={() => setKeywordPopup(null)}
            >
              <div 
                className="bg-white rounded-lg shadow-xl p-6 max-w-4xl max-h-96 overflow-y-auto"
                onClick={(e) => e.stopPropagation()}
              >
                <div className="flex items-center justify-between mb-4">
                  <div>
                    <h3 className="text-lg font-bold text-gray-800">
                      📊 All Sentiment Keywords & Phrases
                    </h3>
                    <p className="text-sm text-gray-600 mt-1">
                      <strong>Sub-Driver:</strong> {keywordPopup.subDriver}
                    </p>
                  </div>
                  <button
                    onClick={() => setKeywordPopup(null)}
                    className="text-gray-500 hover:text-gray-700 hover:bg-gray-100 w-8 h-8 flex items-center justify-center rounded text-2xl font-bold"
                    title="Close"
                  >
                    ✕
                  </button>
                </div>
                
                {/* Positive Keywords */}
                {keywordPopup.keywords.positive && (
                  <div className="mb-4">
                    <h4 className="text-green-700 font-bold mb-2">✅ Positive Keywords & Phrases ({keywordPopup.keywords.positive.reviewCount} reviews)</h4>
                    <div className="bg-green-50 p-3 rounded flex flex-wrap gap-2 border border-green-200">
                      {keywordPopup.keywords.positive.keywords && keywordPopup.keywords.positive.keywords.length > 0 ? (
                        keywordPopup.keywords.positive.keywords.map((keyword, idx) => (
                          <span
                            key={idx}
                            className="px-3 py-2 rounded-full text-sm font-medium text-white bg-green-500"
                          >
                            {keyword}
                          </span>
                        ))
                      ) : (
                        <span className="text-gray-500 text-sm italic">No keywords found</span>
                      )}
                    </div>
                  </div>
                )}
                
                {/* Negative Keywords */}
                {keywordPopup.keywords.negative && (
                  <div className="mb-4">
                    <h4 className="text-red-700 font-bold mb-2">❌ Negative Keywords & Phrases ({keywordPopup.keywords.negative.reviewCount} reviews)</h4>
                    <div className="bg-red-50 p-3 rounded flex flex-wrap gap-2 border border-red-200">
                      {keywordPopup.keywords.negative.keywords && keywordPopup.keywords.negative.keywords.length > 0 ? (
                        keywordPopup.keywords.negative.keywords.map((keyword, idx) => (
                          <span
                            key={idx}
                            className="px-3 py-2 rounded-full text-sm font-medium text-white bg-red-500"
                          >
                            {keyword}
                          </span>
                        ))
                      ) : (
                        <span className="text-gray-500 text-sm italic">No keywords found</span>
                      )}
                    </div>
                  </div>
                )}
                
                {/* Neutral Keywords */}
                {keywordPopup.keywords.neutral && (
                  <div className="mb-4">
                    <h4 className="text-amber-700 font-bold mb-2">⚪ Neutral Keywords & Phrases ({keywordPopup.keywords.neutral.reviewCount} reviews)</h4>
                    <div className="bg-amber-50 p-3 rounded flex flex-wrap gap-2 border border-amber-200">
                      {keywordPopup.keywords.neutral.keywords && keywordPopup.keywords.neutral.keywords.length > 0 ? (
                        keywordPopup.keywords.neutral.keywords.map((keyword, idx) => (
                          <span
                            key={idx}
                            className="px-3 py-2 rounded-full text-sm font-medium text-white bg-amber-500"
                          >
                            {keyword}
                          </span>
                        ))
                      ) : (
                        <span className="text-gray-500 text-sm italic">No keywords found</span>
                      )}
                    </div>
                  </div>
                )}
                
                <button
                  onClick={() => setKeywordPopup(null)}
                  className="mt-4 w-full px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded font-medium"
                >
                  Close
                </button>
              </div>
            </div>
          )}
          </div>
        </div>
      );
    }

    // Rendering the component
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Dashboard />);
  </script>
</body>
</html>




